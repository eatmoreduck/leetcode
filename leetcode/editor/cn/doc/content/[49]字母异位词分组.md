<p>给你一个字符串数组，请你将 <span data-keyword="anagram">字母异位词</span> 组合在一起。可以按任意顺序返回结果列表。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<div class="example-block"> 
 <p><strong>输入:</strong> strs = ["eat", "tea", "tan", "ate", "nat", "bat"]</p> 
</div>

<p><strong>输出: </strong>[["bat"],["nat","tan"],["ate","eat","tea"]]</p>

<p><strong>解释：</strong></p>

<ul> 
 <li>在 strs 中没有字符串可以通过重新排列来形成 <code>"bat"</code>。</li> 
 <li>字符串 <code>"nat"</code> 和 <code>"tan"</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li> 
 <li>字符串 <code>"ate"</code>&nbsp;，<code>"eat"</code>&nbsp;和 <code>"tea"</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li> 
</ul>

<p><strong>示例 2:</strong></p>

<div class="example-block"> 
 <p><strong>输入:</strong> strs = [""]</p> 
</div>

<p><strong>输出: </strong>[[""]]</p>

<p><strong>示例 3:</strong></p>

<div class="example-block"> 
 <p><strong>输入:</strong> strs = ["a"]</p> 
</div>

<p><strong>输出: </strong>[["a"]]</p>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li> 
 <li><code>0 &lt;= strs[i].length &lt;= 100</code></li> 
 <li><code>strs[i]</code>&nbsp;仅包含小写字母</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数组 | 哈希表 | 字符串 | 排序</details><br>

<div>👍 2428, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**Note: English content is improving...**

<details><summary><strong>Brief Thoughts</strong></summary>





<div id="labuladong_solution_en">

## Thoughts

The key to problems involving anagrams lies in how quickly you can determine if two strings are anagrams, which primarily tests the use of data encoding and hash tables:

Can you find an encoding method where all anagrams have the same encoding? Once you find this encoding method, you can use a hash table to store all anagrams with the same encoding, thereby obtaining the final result.

[✨242. Valid Anagram](/problems/valid-anagram/) examines the encoding issue of anagrams. One encoding scheme can be to sort the strings; if they are anagrams, they will look the same after sorting. However, this approach has a slightly higher time complexity and modifies the original data. A better encoding scheme is to use the frequency of each character for encoding, which is what the following solution code does.

</div>


<div id="solution">

## Solution



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// Note: This cpp code is translated by chatGPT🤖 based on my java code.
// This code has passed all the test cases, should be accepted by LeetCode.

#include <vector>
#include <string>
#include <unordered_map>
#include <list>

class Solution {
public:
    std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
        // mapping from code to group
        std::unordered_map<std::string, std::list<std::string>> codeToGroup;
        for (const std::string& s : strs) {
            // encode the string
            std::string code = encode(s);
            // put strings with the same code together
            codeToGroup[code].push_back(s);
        }
        // get the result
        std::vector<std::vector<std::string>> res;
        for (auto& group : codeToGroup) {
            res.push_back(std::vector<std::string>(group.second.begin(), group.second.end()));
        }

        return res;
    }

private:
    // encode using the occurrence count of each character
    std::string encode(const std::string& s) {
        std::string count(26, '0');
        for (char c : s) {
            int delta = c - 'a';
            count[delta]++;
        }
        return count;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# Note: This python code is translated by chatGPT🤖 based on my java code.
# This code has passed all the test cases, should be accepted by LeetCode.

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # mapping from code to group
        codeToGroup = {}
        for s in strs:
            # encode the string
            code = self.encode(s)
            # put strings with the same code together
            if code not in codeToGroup:
                codeToGroup[code] = []
            codeToGroup[code].append(s)
        # get the result
        res = []
        for group in codeToGroup.values():
            res.append(group)

        return res
    # encode using the occurrence count of each character
    def encode(self, s: str) -> str:
        count = [0] * 26
        for c in s:
            delta = ord(c) - ord('a')
            count[delta] += 1
        return ''.join(map(chr, count))
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // mapping from code to group
        HashMap<String, List<String>> codeToGroup = new HashMap<>();
        for (String s : strs) {
            // encode the string
            String code = encode(s);
            // put strings with the same code together
            codeToGroup.putIfAbsent(code, new LinkedList<>());
            codeToGroup.get(code).add(s);
        }
        // get the result
        List<List<String>> res = new LinkedList<>();
        for (List<String> group : codeToGroup.values()) {
            res.add(group);
        }

        return res;
    }
    // encode using the occurrence count of each character
    String encode(String s) {
        char[] count = new char[26];
        for (char c : s.toCharArray()) {
            int delta = c - 'a';
            count[delta]++;
        }
        return new String(count);
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// Note: This go code is translated by chatGPT🤖 based on my java code.
// This code has passed all the test cases, should be accepted by LeetCode.

import (
    "strings"
)

func groupAnagrams(strs []string) [][]string {
    // mapping from code to group
    codeToGroup := make(map[string][]string)
    for _, s := range strs {
        // encode the string
        code := encode(s)
        // put strings with the same code together
        codeToGroup[code] = append(codeToGroup[code], s)
    }
    // get the result
    var res [][]string
    for _, group := range codeToGroup {
        res = append(res, group)
    }

    return res
}
// encode using the occurrence count of each character
func encode(s string) string {
    count := make([]int, 26)
    for _, c := range s {
        count[c-'a']++
    }
    var sb strings.Builder
    for _, num := range count {
        sb.WriteByte(byte(num))
    }
    return sb.String()
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// Note: This javascript code is translated by chatGPT🤖 based on my java code.
// This code has passed all the test cases, should be accepted by LeetCode.

var groupAnagrams = function(strs) {
    // mapping from code to group
    let codeToGroup = new Map();
    for (let s of strs) {
        // encode the string
        let code = encode(s);
        // put strings with the same code together
        if (!codeToGroup.has(code)) {
            codeToGroup.set(code, []);
        }
        codeToGroup.get(code).push(s);
    }
    // get the result
    let res = [];
    for (let group of codeToGroup.values()) {
        res.push(group);
    }

    return res;
};
// encode using the occurrence count of each character
var encode = function(s) {
    let count = new Array(26).fill(0);
    for (let c of s) {
        let delta = c.charCodeAt(0) - 'a'.charCodeAt(0);
        count[delta]++;
    }
    return count.join('#');
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🍭🍭 Algo Visualize 🍭🍭</strong></summary><div id="data_group-anagrams"  en="true" category="leetcode" ></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_group-anagrams"></div></div>
</details><hr /><br />

</div>
</details>
</div>

